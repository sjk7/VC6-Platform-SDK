/*
    Copyright Microsoft Corp. 1992 - 2001

    File Replication Sample
    Client System Service

    FILE: FileRepClientProc.cpp
    
    PURPOSE: Remote procedures for client system service
    
    FUNCTIONS:
        RequestFile() - receives file replication requests
        ThreadProcRequest() - processes file replication requests
    in an independent thread.

    COMMENTS:

*/

#include <stdlib.h>
#include <stdio.h>
#include <tchar.h>
#include <rpc.h>
#include <Ntdsapi.h>
#include <time.h>

#include "common.h"

// header file generated by MIDL compiler
#include "FileRepClient.h"
#include "FileRepServer.h"

// Contains declarations for system service functions.
#include "Service.h"

#ifdef DEBUG
#include "DbgMsg.h"
#endif

#ifdef PROF
#include "Prof.h"
#endif

// The number of seconds we will spend on the RPC
// thread before spawning a new worker thread.
const time_t tServerThread = 5;

typedef enum tReqState {
    StateArrived,
    StateQueued,
    StateActive
} ReqState;

//
// Packages up the variables to be passed
// to the processing thread.
//
typedef struct tReq{
    handle_t hFileRepServer;
    handle_t hFileRepClient;
    HANDLE hTokenHandle;
    HANDLE hLocalFile;
    PCONTEXT_HANDLE_TYPE phContext;

    LPTSTR ServerName;
    LPTSTR RemoteFileName;
    LPTSTR LocalFileName;

    // Set when we are impersonating the client.
    BOOL bRpcImpersonating;
    BOOL bImpersonating;

    // Priority of this request.
    UINT Pri;

    // User SID.
    PSID pSID;

    ReqState State;

#ifdef PROF
    ULONG nReqId;
#endif
} Req;

//
// Closes the file handle and frees all thread data if an error occured
// in one of the following functions.
//
VOID ShutdownThread(Req *pReq) {
    DWORD status;
    RPC_STATUS rpcstatus;

#ifdef DEBUG
    TCHAR Msg[MSG_SIZE];

    DbgMsgRecord(TEXT("-> ShutdownThread\n"));
#endif

    if(pReq != NULL) {

        // Stop impersonating if we are.
        // The first thing we do in handling a request is impersonating the client.
        if (pReq->bRpcImpersonating) {
            rpcstatus = RpcRevertToSelf();
            if (rpcstatus != RPC_S_OK) {
                AddToMessageLogProcFailureEEInfo(TEXT("ShutdownThread: RpcRevertToSelf"), rpcstatus);
            }
        }
        if (pReq->bImpersonating) {
            if (RevertToSelf() == 0) {
                AddToMessageLogProcFailure(TEXT("ShutdownThread: RevertToSelf"), GetLastError());
            }
        }

        if(pReq->hFileRepServer != NULL) {
            rpcstatus = RpcBindingFree(&(pReq->hFileRepServer));
            ASSERTE(rpcstatus == RPC_S_OK);
        }
        // Check that hLocalFile has been initialized and that initialization
        // was successful.
        if(pReq->hLocalFile != NULL && pReq->hLocalFile != INVALID_HANDLE_VALUE) {
            status = CloseHandle(pReq->hLocalFile);
            ASSERTE(status != 0);
        }
        if(pReq->phContext != NULL) {
            RpcSsDestroyClientContext((VOID **)&pReq->phContext);
            if (rpcstatus != RPC_S_OK) {
                AddToMessageLogProcFailureEEInfo(TEXT("ShutdownThread: RpcSsDestroyClientContext"), rpcstatus);
            }
        }

        // Check if any of the counters need to be decremented
        // since we are removing the request.
        if (pReq->State == StateQueued) {
            CounterDecrement(pClientReqCounters[pReq->Pri]);
#ifdef DEBUG
            _stprintf(Msg, TEXT("Decremented ClientReqCounters[%d]\n"), pReq->Pri);
            DbgMsgRecord(Msg);
#endif            
        }
        if (pReq->State == StateActive) {
            CounterDecrement(pClientActiveReqCounters[pReq->Pri]);
            QueueHashDecrementCounter(ClientActiveReqHashCounters[pReq->Pri], pReq->pSID);
#ifdef DEBUG
            _stprintf(Msg, TEXT("Decremented ClientActiveReqCounters[%d] and ClientActiveReqHashCounters[%d]\n"), pReq->Pri, pReq->Pri);
            DbgMsgRecord(Msg);
#endif            
        }

        if (pReq->hTokenHandle != NULL) {
            status = CloseHandle(pReq->hTokenHandle);
            ASSERTE(status != NULL);
        }

        if (pReq->ServerName != NULL) {
            AutoHeapFree(pReq->ServerName);
        }
        if (pReq->RemoteFileName != NULL) {
            AutoHeapFree(pReq->RemoteFileName);
        }
        if (pReq->LocalFileName != NULL) {
            AutoHeapFree(pReq->LocalFileName);
        }
        
        if (pReq->pSID != NULL) {
            AutoHeapFree(pReq->pSID);
        }

        AutoHeapFree(pReq);
    }

#ifdef DEBUG
    DbgMsgRecord(TEXT("<- ShutdownThread\n"));
#endif
}

//
// Handles a request taken off req queue.
//
VOID HandleReq(tReq *pReq) {

    BYTE pbBuf[MAX_BUFSIZE];

    RPC_STATUS rpcstatus;

    ULONG cbRead, cbWritten;

    // Default connection to server system service is over TCP/IP.
    LPTSTR DefaultProtocolSequence = TEXT("ncacn_ip_tcp");
    
    // An empty endpoint string is used, since we are going to
    // connect to the endpoint dynamically generated by the
    // RPC run-time library.    Server calls RpcServerUseProtseq to
    // obtain a binding hadnle and a dynamic endpoint.
    LPTSTR DefaultEndpoint = TEXT("");

    LPTSTR pszUuid = NULL;
    LPTSTR pszOptions = NULL;
    LPTSTR pszStringBinding = NULL;

    BOOL FoundReq = TRUE;
    BOOL FoundActiveReq = TRUE;

    //
    // If a request is picked of the request queue.
    // Then we need to set up binding, bind to the server,
    // and do the initial read.
    //
                
    // We need to impersonate the user that has issued the
    // remote call.
    // We want to impersonate as soon as possible to minimise
    // the amount of resources that can be consumed by an attack.
    if (ImpersonateLoggedOnUser(pReq->hTokenHandle) == 0) {      
        ShutdownThread(pReq);
        AddToMessageLogProcFailure(TEXT("HandleReq: ImpersonateLoggedOnUser"), GetLastError());
        return;
    }
    pReq->bImpersonating = TRUE;
                
    // Prepare the binding information.
    if ((rpcstatus = RpcStringBindingCompose(pszUuid,
                                             DefaultProtocolSequence,
                                             pReq->ServerName,
                                             DefaultEndpoint,
                                             pszOptions,
                                             &pszStringBinding)) != RPC_S_OK) {
        ShutdownThread(pReq);
        AddToMessageLogProcFailureEEInfo(TEXT("HandleReq: RpcStringBindingCompose"), rpcstatus);
        return;
    }
                
    if ((rpcstatus = RpcBindingFromStringBinding(pszStringBinding, &(pReq->hFileRepServer))) != RPC_S_OK) {
        // The binding handle is invalid
        pReq->hFileRepServer = NULL;
                    
        // Deallocate the string binding.
        rpcstatus = RpcStringFree(&pszStringBinding);
        ASSERTE(rpcstatus == RPC_S_OK);
                    
        ShutdownThread(pReq);
        AddToMessageLogProcFailureEEInfo(TEXT("HandleReq: RpcBindingFromStringBinding"), rpcstatus);
        return;
    }
                
    // We need to delete the string binding, since it is no longer
    // necessary.  All the binding information is now contained in the
    // binding handle.
    rpcstatus = RpcStringFree(&pszStringBinding);
    ASSERTE(rpcstatus == RPC_S_OK);    
                
    DWORD status;

    // Quality of service structure to ensure authentication.
    RPC_SECURITY_QOS SecurityQOS;

    // The length of the principal name and the principal name
    // for the client system service.
    TCHAR szSpn[MAX_PATH];
    ULONG ulSpn = sizeof(szSpn);

    // Generate a principal name for the local system service.
    if ((status = DsMakeSpn(SERVICENAME,
                            pReq->ServerName,
                            NULL,
                            0,
                            0,
                            &ulSpn,
                            szSpn)) != ERROR_SUCCESS) {
        ShutdownThread(pReq);
        AddToMessageLogProcFailure(TEXT("HandleReq: DsMakeSpn"), GetLastError());
        return;
    }
                
    // Specify quality of service parameters.
    SecurityQOS.Version = RPC_C_SECURITY_QOS_VERSION;
    SecurityQOS.Capabilities = RPC_C_QOS_CAPABILITIES_MUTUAL_AUTH;
    // Use static identity tracking since we will be issuing multiple
    // RPC calls from this thread with different identities: while
    // impersonating, and while not.  This insures that all the calls will
    // go to server under the identity of the user who created the binding
    // handle.
    SecurityQOS.IdentityTracking = RPC_C_QOS_IDENTITY_STATIC;
    // The client system service needs to impersonate the security context
    // of the client utility on the remote systems where it may replicate
    // files from.  It will also need to obtain client's SID and hence
    // requires impersonation.
    SecurityQOS.ImpersonationType = RPC_C_IMP_LEVEL_IMPERSONATE;
                
    // Set authentification and authorisation information for
    // the binding handle.
    if ((rpcstatus = RpcBindingSetAuthInfoEx(pReq->hFileRepServer, szSpn, RPC_C_AUTHN_LEVEL_PKT_PRIVACY, RPC_C_AUTHN_GSS_KERBEROS, NULL, RPC_C_AUTHZ_NAME, &SecurityQOS)) != RPC_S_OK) {

        ShutdownThread(pReq);
        AddToMessageLogProcFailureEEInfo(TEXT("HandleReq: RpcBindingSetAuthInfoEx"), rpcstatus);
        return;
    }

    // We did not read anything yet.
    cbRead = 0;
                
#ifdef RETRY_EXCEPTION
    // When making aggressive calls to the server, this flag is
    // set when the call succeeded.  This makes the client service attempt
    // to contact the server even after an exception occured.
    BOOL bRetryCall = TRUE;
    while (bRetryCall) {
#endif
                    
        // Attempt to open the remote file.
        RpcTryExcept {
            c_RemoteOpen(pReq->hFileRepServer,
                         &(pReq->phContext),
                         pReq->RemoteFileName,
                         pbBuf,
                         &cbRead);    
#ifdef RETRY_EXCEPTION
            bRetryCall = FALSE;
#endif
        }
        RpcExcept ( ( (RpcExceptionCode() != STATUS_ACCESS_VIOLATION) &&
                      (RpcExceptionCode() != STATUS_DATATYPE_MISALIGNMENT) &&
                      (RpcExceptionCode() != STATUS_PRIVILEGED_INSTRUCTION) &&
                      (RpcExceptionCode() != STATUS_ILLEGAL_INSTRUCTION) &&
                      (RpcExceptionCode() != STATUS_BREAKPOINT) )
                    ? EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH ) {
                        
#ifdef RETRY_EXCEPTION
            // This code attempts to make aggressive calls, retrying
            // if no endpoints are available.  It is used to put servers
            // under stress.
            if (RpcExceptionCode() != EPT_S_NOT_REGISTERED &&
                RpcExceptionCode() != RPC_S_SERVER_UNAVAILABLE) {
#endif
                // Deallocate all the thread data before failing.
                ShutdownThread(pReq);
                AddToMessageLogProcFailureEEInfo(TEXT("HandleReq: c_RemoteOpen"), RpcExceptionCode());
                return;
#ifdef RETRY_EXCEPTION
            }
#endif                    
        }
        RpcEndExcept;
#ifdef RETRY_EXCEPTION
    }
#endif
                
    // Attempt to open the local file.
    if ((pReq->hLocalFile = CreateFile(pReq->LocalFileName,
                                       GENERIC_WRITE,
                                       0,
                                       NULL,
                                       CREATE_ALWAYS,
                                       FILE_ATTRIBUTE_NORMAL,
                                       NULL)) == INVALID_HANDLE_VALUE) {
        ShutdownThread(pReq);
        AddToMessageLogProcFailure(TEXT("HandleReq: CreateFile"), GetLastError());
        return;
    }

    // We need to stop impersonating before putting this request back into
    // a queue or quitting.
    if (RevertToSelf() == 0) {
        AddToMessageLogProcFailure(TEXT("HandleReq: RevertToSelf"), GetLastError());
    }

    // Write the data received to local file.
    if(!WriteFile(pReq->hLocalFile,
                  pbBuf,
                  cbRead,
                  &cbWritten,
                  NULL)){
                    
        ShutdownThread(pReq);
        AddToMessageLogProcFailure(TEXT("HandleReq: WriteFile"), GetLastError());
        return;
    }
                
    // If there are no errors and the call returned NULL, then
    // the file was read in a single call and has already been closed.
    // We just need to write the buffer and go for the next round.
    if(pReq->phContext == NULL){
#ifdef PROF
        ProfRecordTime(pReq->nReqId, TEXT("handled"));
#endif
        ShutdownThread(pReq);
        return;
    }
                
    // Now put the request onto the appropriate active request queue.
    // Lookup the subqueue for the user's sid.
    QueueHashAddToSubqueue(ClientActiveReqHashQueues[pReq->Pri], pReq->pSID, pReq);

#ifdef DEBUG
    TCHAR Msg[MSG_SIZE];

    _stprintf(Msg, TEXT("RequestFile: Put req %p onto ActiveReq queue %p\n"), pReq, ClientActiveReqHashQueues[pReq->Pri]);
    DbgMsgRecord(Msg);
#endif            
}

//
// Handles a request taken off active req queue
//
VOID HandleActiveReq(tReq *pReq) {

    BYTE pbBuf[MAX_BUFSIZE];

    ULONG cbRead, cbWritten;

    //
    // If a request for process is picked of the active request queue.
    // Then we simply need to read another segment and finish the request
    // if necessary.
    //
            
    // Get the remainder of text from the remote file.  When the
    // server returns a NULL context handle, the read has completed and
    // the file has been closed.
    
    // We did not read anything yet.
    cbRead = 0;
            
#ifdef RETRY_EXCEPTION
    // When making aggressive calls to the server, this flag is
    // set when the call succeeded.  This makes the client service attempt
    // to contact the server even after an exception occured.
    BOOL bRetryCall = TRUE;
    while (bRetryCall) {
#endif
                
        RpcTryExcept {
            c_RemoteRead(pReq->hFileRepServer,
                         &(pReq->phContext),
                         pbBuf,
                         &cbRead);                    
#ifdef RETRY_EXCEPTION
            bRetryCall = FALSE;
#endif
        }
        RpcExcept ( ( (RpcExceptionCode() != STATUS_ACCESS_VIOLATION) &&
                      (RpcExceptionCode() != STATUS_DATATYPE_MISALIGNMENT) &&
                      (RpcExceptionCode() != STATUS_PRIVILEGED_INSTRUCTION) &&
                      (RpcExceptionCode() != STATUS_ILLEGAL_INSTRUCTION) &&
                      (RpcExceptionCode() != STATUS_BREAKPOINT))
                    ? EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH ) {
                    
            // Log the error code as well as the error.
            // Msg is sufficiently large and can't overflow.
            AddToMessageLogProcFailureEEInfo(TEXT("HandleActiveReq: c_RemoteRead"), RpcExceptionCode());
                    
#ifdef RETRY_EXCEPTION
            // This code attempts to make aggressive calls, retrying
            // if no endpoints were available.  It is used to put servers
            // under stress.
            if (RpcExceptionCode() != EPT_S_NOT_REGISTERED &&
                RpcExceptionCode() != RPC_S_SERVER_UNAVAILABLE) {
#endif
                // Dump this request.
                ShutdownThread(pReq);
                return;
#ifdef RETRY_EXCEPTION
            }
#endif
        }
        RpcEndExcept;                
#ifdef RETRY_EXCEPTION
    }
#endif
    
    // Access check was done on opening when we were impersonating.
    // Thus we do not need to impersonate in this code.
    if(!WriteFile(pReq->hLocalFile,
                  pbBuf,
                  cbRead,
                  &cbWritten,
                  NULL)) {
                
        AddToMessageLogProcFailure(TEXT("HandleActiveReq: WriteFile failed with code %d"), GetLastError());
        ShutdownThread(pReq);
        return;
    }
            
    if (pReq->phContext == NULL) {
#ifdef PROF
        ProfRecordTime(pReq->nReqId, TEXT("handled"));
#endif
        ShutdownThread(pReq);
    }
    else {
        // We are not done and the request needs to go back onto queue.
        // Put the request onto the appropriate active request queue.
        QueueHashAddToSubqueue(ClientActiveReqHashQueues[pReq->Pri], pReq->pSID, pReq);

#ifdef DEBUG
        TCHAR Msg[MSG_SIZE];

        _stprintf(Msg, TEXT("RequestFile: Put req %p onto ActiveReq queue %p\n"), pReq, ClientActiveReqHashQueues[pReq->Pri]);
        DbgMsgRecord(Msg);
#endif            
    }
}

//
// Handles the requests placed on req queue and active req queue
// and returns when no requests are available.
//
VOID ServiceRequests(BOOL bIsRPCThread) {

    UINT i = 0;

    time_t tReqArrived;

#ifdef DEBUG
    TCHAR Msg[MSG_SIZE];
#endif

    DWORD status;

    Req *pReq = NULL;

    BOOL FoundReq = TRUE;
    BOOL FoundActiveReq = TRUE;

    ULONG ThreadIdentifier;
    HANDLE hThread;

    tReqArrived = time(NULL);

    //
    // We will now go and check if the request or the active request sets of queues have anything that we
    // can service.  If they do not, then this thread can terminate.
    //

    while(FoundReq || FoundActiveReq) {

        // If this thread has handled too many requests
        // we want to allow it to return.  We will spawn a new
        // worker thread in its place.
        // This way a client will receive the synchronous reply.
        
        if (bIsRPCThread && ((time(NULL) - tReqArrived) >= tServerThread)) {
            if ((hThread = CreateThread(NULL,
                                        0,
                                        (LPTHREAD_START_ROUTINE) ServiceRequests,
                                        (PVOID) FALSE,
                                        0,
                                        &ThreadIdentifier)) == NULL) {
                
                ShutdownThread(pReq);
                AddToMessageLogProcFailure(TEXT("ServiceRequests: CreateThread"), GetLastError());
                return;
            }
            
            // Unless we close a handle to the thread, it will remain in the
            // system even after its execution has terminated.
            status = CloseHandle(hThread);
            ASSERTE(status != 0);
    
            return;
        }

        // Check if the request queues have anything on them.  If they do,
        // pick a request off the highest priority queue and handle it, but only if we
        // are not handling enough of those requests already.
        for (UINT pri = NumPriGroups; pri > 0; pri--) {
            pReq = (Req *) QueueRemove(ClientReqQueues[pri-1]);
            if (pReq != NULL) {
                break;
            }
	}

        if (pReq != NULL) {

#ifdef DEBUG
            _stprintf(Msg, TEXT("RequestFile: Took req %p off Req queue %p\n"), pReq, ClientReqQueues[pReq->Pri]);
            DbgMsgRecord(Msg);
#endif
          
            if (CounterIncrement(pClientActiveReqCounters[pReq->Pri])) {
                if (QueueHashIncrementCounter(ClientActiveReqHashCounters[pReq->Pri], pReq->pSID)) {
#ifdef DEBUG
                    _stprintf(Msg, TEXT("Incremented ClientActiveReqCounters[%d] and ClientActiveReqHashCounters[%d]\n"), pReq->Pri, pReq->Pri);
                    DbgMsgRecord(Msg);
#endif
                    FoundReq = TRUE;
                
                    // The request now resides on a new queue.
                    CounterDecrement(pClientReqCounters[pReq->Pri]);
#ifdef DEBUG
                    _stprintf(Msg, TEXT("Decremented ClientReqCounters[%d]\n"), pReq->Pri);
                    DbgMsgRecord(Msg);
#endif            
                    pReq->State = StateActive;
                    
                    HandleReq(pReq);
                }
                else {
                    // There were too many requests for a given SID, place the request back
                    // onto the queue.
                    
                    // Don't forget to decrement the counter for the group!
                    CounterDecrement(pClientActiveReqCounters[pReq->Pri]);

                    QueueAdd(ClientReqQueues[pReq->Pri], pReq, TRUE);

                    // Even though we found a request, we could not process it.
                    // Thus, to ensure that a thread will not spin waiting for space
                    // for an active request we set this flag.
                    FoundReq = FALSE;

#ifdef DEBUG
                    _stprintf(Msg, TEXT("Too many active requests for a SID\n"));
                    DbgMsgRecord(Msg);
                    _stprintf(Msg, TEXT("RequestFile: Put req %p onto Req queue %p\n"), pReq, ClientReqQueues[pReq->Pri]);
                    DbgMsgRecord(Msg);
#endif
                }
            }
            else {
                // There were too many active requests for the user group, place the request back
                // onto the queue.
                
                QueueAdd(ClientReqQueues[pReq->Pri], pReq, TRUE);

                FoundReq = FALSE;

#ifdef DEBUG
                _stprintf(Msg, TEXT("Too many active requests for priority %d\n"), pReq->Pri);
                DbgMsgRecord(Msg);
                _stprintf(Msg, TEXT("RequestFile: Put req %p onto Req queue %p\n"), pReq, ClientReqQueues[pReq->Pri]);
                DbgMsgRecord(Msg);
#endif
            }
        }
        else {
            // We did not find any passive queued requests to be handled.
            FoundReq = FALSE;
        }
        
        // Check if the active request queues have anything on them.  If they do,
        // pick a request off the highest priority queue and handle it.
        for (pri = NumPriGroups; pri > 0; pri--) {
            pReq = (Req *) QueueHashRemoveFromSubqueue(ClientActiveReqHashQueues[pri-1]);
            if (pReq != NULL) {
                break;
            }
        }
        
        if (pReq != NULL) {
            
            FoundActiveReq = TRUE;
            
#ifdef DEBUG
            _stprintf(Msg, TEXT("RequestFile: Took req %p off ActiveReq queue %p\n"), pReq, ClientActiveReqHashQueues[pReq->Pri]);
            DbgMsgRecord(Msg);
#endif
            HandleActiveReq(pReq);
        }
        else {
            // We did not find any active requests to be handled.
            FoundActiveReq = FALSE;
        }
    }

    // No requests on either of the queues; the thread can return.
}

/*
    FUNCTIONS: IsSecureClient

    PURPOSE:
        Returns TRUE if the service is being contacted by a proper
      authenticated client.

    PARAMETERS:
        Self-explanatory.

    RETURN VALUE: TRUE if YES, FALSE otherwise or on error.
 
*/
BOOL IsSecureClient(handle_t hFileRepClient, Req *pReq) {
    RPC_AUTHZ_HANDLE hAuth;
    ULONG ulAuthnLevel;

    // Get client security info.
    if (RpcBindingInqAuthClient(pReq->hFileRepClient,
                                &hAuth,
                                NULL,
                                &ulAuthnLevel,
                                NULL,
                                NULL) != RPC_S_OK) {
        AddRpcEEInfo(GetLastError(), TEXT("RequestFile: RpcBindingInqAuthClient failed"));
        return FALSE;
    }
    
    // Make sure the client has adequate security measures.
    // Since this is LRPC, we get the security level of privacy
    // because it is the only available security level.
    // We do not interoperate with old versions of FileRep 
    // client utilities, since appropriate versions should be
    // available with the local system service.
    if (ulAuthnLevel != RPC_C_AUTHN_LEVEL_PKT_PRIVACY) {
        AddRpcEEInfo(RPC_S_SEC_PKG_ERROR, TEXT("RequestFile: ulAuthnLevel != RPC_C_AUTHN_LEVEL_PKT_PRIVACY"));
        return FALSE;
    }

    return TRUE;
}

/*
    FUNCTIONS: RequestFile

    PURPOSE:
        Called by FileRep to have the Client System
      Service request file replication from a Server System Service.
      The function processes rpc request and places it in a request
      queue.  It then checks the request and active request queues for
      requests to process, or exits.

    PARAMETERS:
        Self-explanatory.

    RETURN VALUE: none
 
*/
VOID RequestFile(handle_t hFileRepClient,
                 LPTSTR ServerName,
                 LPTSTR RemoteFileName,
                 LPTSTR LocalFileName) {

    RPC_STATUS rpcstatus;

    Req *pReq = NULL;

    // The string binding that is used to make sure clients contact the
    // service via an LRPC call.
    LPTSTR StringBinding;
    
    // The protocol sequence that gets extracted from the string binding.
    LPTSTR ProtSeq;

    TCHAR Msg[MSG_SIZE];

#ifdef DEBUG
    DbgMsgRecord(TEXT("-> RequestFile\n"));
#endif

    if((pReq = (Req *) AutoHeapAlloc(sizeof(Req))) == NULL) {
        AddRpcEEInfoAndRaiseException(ERROR_OUTOFMEMORY, TEXT("RequestFile: AutoHeapAlloc failed"));            
        return;
    }

    // Set pReq' fields to NULL so that we will know
    // in ShutdownThread which ones have been initialized.
    pReq->hFileRepServer = NULL;

    pReq->hFileRepClient = hFileRepClient;

    pReq->hTokenHandle = NULL;

    pReq->hLocalFile = NULL;
    pReq->phContext = NULL;
    pReq->bRpcImpersonating = FALSE;
    pReq->bImpersonating = FALSE;
    pReq->Pri = 0;
    pReq->State = StateArrived;

    pReq->ServerName = NULL;
    pReq->RemoteFileName = NULL;
    pReq->LocalFileName = NULL;

    pReq->pSID = NULL;

    // Copy strings out since they may need to be allocated longer then
    // the arguments that live on the stack.
    // It is conceivable that this thread will put the
    // request on the queue and some other thread will
    // handle the request after this thread has exited.
    if ((pReq->ServerName = (LPTSTR) AutoHeapAlloc((_tcslen(ServerName)+1) * sizeof(TCHAR))) == NULL) {
        ShutdownThread(pReq);
        AddRpcEEInfoAndRaiseException(ERROR_OUTOFMEMORY, TEXT("RequestFile: AutoHeapAlloc failed"));            
        return;
    }
    CopyMemory(pReq->ServerName, ServerName, (_tcslen(ServerName)+1) * sizeof(TCHAR));
    if ((pReq->RemoteFileName = (LPTSTR) AutoHeapAlloc((_tcslen(RemoteFileName)+1) * sizeof(TCHAR))) == NULL) {
        ShutdownThread(pReq);
        AddRpcEEInfoAndRaiseException(ERROR_OUTOFMEMORY, TEXT("RequestFile: AutoHeapAlloc failed"));            
        return;
    }
    CopyMemory(pReq->RemoteFileName, RemoteFileName, (_tcslen(RemoteFileName)+1) * sizeof(TCHAR));
    if ((pReq->LocalFileName = (LPTSTR) AutoHeapAlloc((_tcslen(LocalFileName)+1) * sizeof(TCHAR))) == NULL) {
        ShutdownThread(pReq);
        AddRpcEEInfoAndRaiseException(ERROR_OUTOFMEMORY, TEXT("RequestFile: AutoHeapAlloc failed"));
        return;
    }
    CopyMemory(pReq->LocalFileName, LocalFileName, (_tcslen(LocalFileName)+1) * sizeof(TCHAR));

#ifdef PROF
    static ULONG nTotalId;

    EnterCriticalSection(&ProfCriticalSection);

    // Record the number of the current request.
    pReq->nReqId = nTotalId;
    // Increment the number of the request.
    nTotalId++;

    LeaveCriticalSection(&ProfCriticalSection);

    _stprintf(Msg, TEXT("name=\"%s\" arrived"), RemoteFileName);
    
    // Record the time of arrival of this request.
    ProfRecordTime(pReq->nReqId, Msg);
#endif

    // Make sure that the client utility is local.
    // Client system service only services LRPC calls.
    if ((rpcstatus = RpcBindingToStringBinding(pReq->hFileRepClient, &StringBinding)) != RPC_S_OK) {
        ShutdownThread(pReq);
        AddRpcEEInfoAndRaiseException(rpcstatus, TEXT("RequestFile: RpcBindingToStringBinding failed"));
        return;
    }
    if ((rpcstatus = RpcStringBindingParse(StringBinding, NULL, &ProtSeq, NULL, NULL, NULL)) != RPC_S_OK) {

        // Free the string binding.
        rpcstatus = RpcStringFree(&StringBinding);
        ASSERTE(rpcstatus == RPC_S_OK);

        ShutdownThread(pReq);
        AddRpcEEInfoAndRaiseException(rpcstatus, TEXT("RequestFile: RpcStringBindingParse failed"));
        return;
    }
    if (_tcscmp(ProtSeq, TEXT("ncalrpc")) != 0) {

        // Free the string binding.
        rpcstatus = RpcStringFree(&StringBinding);
        ASSERTE(rpcstatus == RPC_S_OK);
        // And the protocol sequence
        rpcstatus = RpcStringFree(&ProtSeq);
        ASSERTE(rpcstatus == RPC_S_OK);

        ShutdownThread(pReq);
        AddRpcEEInfoAndRaiseException(RPC_S_INVALID_RPC_PROTSEQ, TEXT("RequestFile: _tcscmp(ProtSeq, TEXT(\"ncalrpc\")) != 0"));
        return;
    }

    // Free the string binding.
    rpcstatus = RpcStringFree(&StringBinding);
    ASSERTE(rpcstatus == RPC_S_OK);
    // And the protocol sequence.
    rpcstatus = RpcStringFree(&ProtSeq);
    ASSERTE(rpcstatus == RPC_S_OK);

    if (!IsSecureClient(hFileRepClient, pReq)) {
        ShutdownThread(pReq);
        AddRpcEEInfoAndRaiseException(RPC_S_SEC_PKG_ERROR, TEXT("RequestFile: IsSecureClient failed"));
        return;
    }

    //
    // Check that we are not exceeding the bound on the number
    // of concurrent requests for this user's priority group.
    // And update the number of such requests.
    //

    // Impersonate the caller so that we can get the caller's SID
    if ((rpcstatus = RpcImpersonateClient(pReq->hFileRepClient)) != RPC_S_OK) {      
        ShutdownThread(pReq);
        AddRpcEEInfoAndRaiseException(rpcstatus, TEXT("RequestFile: RpcImpersonateClient failed"));
        return;
    }
    pReq->bRpcImpersonating = TRUE;

    // We need to write down the access token for the user so that
    // we can use it for impersonation later when the client binding handle
    // gets deallocated.
    if (OpenThreadToken(GetCurrentThread(),
                        TOKEN_QUERY | TOKEN_IMPERSONATE,
                        TRUE,
                        &pReq->hTokenHandle) == 0) {

        ShutdownThread(pReq);
        AddRpcEEInfoAndRaiseException(GetLastError(), TEXT("RequestFile: OpenThreadToken failed"));
        return;
    }

    // Determine current user's priority level.  This corresponds to the
    // priority level of the callee, since we are impersonating.
    pReq->Pri = GetCurrentUserPriority();

    // Write down the SID for the user.
    pReq->pSID = GetUserSID();

    // Stop impersonating.  We got what we wanted.
    if ((rpcstatus = RpcRevertToSelf()) != RPC_S_OK) {
        pReq->bRpcImpersonating = FALSE;
        
        ShutdownThread(pReq);
        AddRpcEEInfoAndRaiseException(rpcstatus, TEXT("RequestFile: RpcRevertToSelf failed"));
        return;
    }
    pReq->bRpcImpersonating = FALSE;

#ifdef DEBUG
    _stprintf(Msg, TEXT("RequestFile: Pri=%d for req %p\n"), pReq->Pri, pReq);
    DbgMsgRecord(Msg);
#endif

    // Increment the counter for the number of concurrent requests.
    if (!CounterIncrement(pClientReqCounters[pReq->Pri])) {

        ShutdownThread(pReq);
        // We have to raise exception after deallocating the data
        // since there is a possibility that a client thread
        // will retry and will attempt to open this local file
        // while it's previous request is still holding a lock.
        // This has been actually hit on an overloaded system.
        AddRpcEEInfoAndRaiseException(RPC_S_SERVER_TOO_BUSY, TEXT("RequestFile: CounterIncrement failed"));
        return;
    }
#ifdef DEBUG
    _stprintf(Msg, TEXT("Incremented ClientReqCounters[%d]\n"), pReq->Pri);
    DbgMsgRecord(Msg);
#endif            
    
    pReq->State = StateQueued;

    // Place the request onto the queue.
    QueueAdd(ClientReqQueues[pReq->Pri], pReq, TRUE);
#ifdef DEBUG
    _stprintf(Msg, TEXT("RequestFile: Put req %p onto Req queue %p\n"), pReq, ClientReqQueues[pReq->Pri]);
    DbgMsgRecord(Msg);
#endif    

    //
    // After this point we can not throw exceptions, because we may be handling
    // a different request after placing the arriving request onto the queue.
    // We will log messages instead.
    //

    // Go service some requests, remember that you are
    // an RPC thread.
    ServiceRequests(TRUE);

#ifdef DEBUG
    DbgMsgRecord(TEXT("<- RequestFile\n"));
#endif
    
    return;
}

// end FileRepClientProc.cpp
