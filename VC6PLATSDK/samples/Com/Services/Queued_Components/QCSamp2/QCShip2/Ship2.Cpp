/*+==========================================================================
  File:      Ship2.cpp
  Summary:   Implementation of COShip2 class
  Classes:   Implemented: COShip2
			 Used: ADO  CLSID_ADOConnection
			 Used: COM+ ObjectContext
  Methods:   put_CustomerId
			 put_OrderId
			 LineItem
			 ProcessOrder
  Origin:    Implementation of case study in Queued Components specification
----------------------------------------------------------------------------
  Copyright 1992 - 2000 Microsoft Corporation, All rights reserved.

    THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
    ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
    THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
    PARTICULAR PURPOSE
==========================================================================+*/ 

#include "stdafx.h"
#include "..\DataSourceNames.h"	// ADO Data Source Names, userid, password
#include <adoid.h>		// OLEDBSDK ADO
#include <adoint.h>		// OLEDBSDK ADO
#include "QCShip2.h"		// Generated by MIDL from QCShip2.idl
#include "Ship2.h"		// Our class header
#include "..\QCOrder\processFlags.h"

/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   COShip2::put_CustomerId
  Summary:  property put for CustomerId property
  Args:     long lCustomerId			A customer identifier.
  Modifies: class member variable m_lCustomerId
  Returns:  HRESULT	- Always returns S_OK
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/ 

STDMETHODIMP COShip2::put_CustomerId(long lCustomerId)
{
	m_lCustomerId = lCustomerId;
	return S_OK;
}

/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   COShip2::put_OrderId
  Summary:  property put for OrderId property
  Args:     long lOrderId			An order identifier.
  Modifies: class member variable m_lOrderId
  Returns:  HRESULT	- Always returns S_OK
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/ 

STDMETHODIMP COShip2::put_OrderId(long lOrderId)
{
	m_lOrderId = lOrderId;
	return S_OK;
}

/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   COShip2::LineItem
  Summary:  Adds a single item to an order
  Args:     long lItemId			An item identifier (e.g. stock identifier)
			long lQuantity			The quantity of the item ordered
  Modifies: class members m_veclItemId, m_veclQuantity, m_vecShipStatus 
  Returns:  HRESULT	- Always returns S_OK
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/ 

STDMETHODIMP COShip2::LineItem(long lItemId, long lQuantity)
{
	m_veclItemId.push_back(lItemId);
	m_veclQuantity.push_back(lQuantity);
	m_vecShipStatus.push_back(RandomShipStatus());	// assign shipping status
	return S_OK;
}

/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   COShip2::Process
  Summary:  Writes order to Shipping database.
			Creates Notify object to inform requestor of shipping statuses.
  Args:     long	lFlags - option flags (see constants in IDL file)
  Modifies: Rows in Shipping table (DSN = QCSampOrder)
			Issues COM+ SetComplete or SetAbort depending on request success.
  Returns:  HRESULT	- returns failure from embedded function requests or S_OK.
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/ 

STDMETHODIMP COShip2::Process(long lFlags, IUnknown *punk)
{
	HRESULT hr = S_OK;

	_RPT1(_CRT_WARN, "QCSamp2 %d Ship2\n", m_lOrderId);
	
	if (lFlags & processFlagWriteDB) hr = WriteShipDB();

	if (SUCCEEDED(hr)) hr = NotifyRequestor(lFlags, punk);

	// Invoke SetComplete or SetAbort depending on our success

	CComPtr<IObjectContext> pIObjectContext;

	if (SUCCEEDED(CoGetObjectContext(IID_IObjectContext, (void**)&pIObjectContext)))
	{
		if (SUCCEEDED(hr))	pIObjectContext->SetComplete();
		else				pIObjectContext->SetAbort();
	}

	return hr;
}

/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  THIS IS A PRIVATE MEMBER FUNCTION

  Method:   COShip2::WriteShipDB
  Summary:  Writes order to Shipping database.
  Args:     None
  Modifies: Adds rows in Shipping table (DSN = QCSampleShip)
  Returns:  HRESULT	- returns failure from embedded function requests or S_OK.
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/ 

HRESULT COShip2::WriteShipDB()
{
	CComPtr<ADOConnection> pADOConnection;

	HRESULT hr = CoCreateInstance(	CLSID_CADOConnection, NULL, CLSCTX_INPROC_SERVER,
									IID_IADOConnection, (void **) &pADOConnection);
	if (SUCCEEDED(hr))
	{
		// Connect to the Shipping Database. Names in DataSourceNames.h

		hr = pADOConnection->Open(	_bstr_t(pszShipDSN), _bstr_t(pszUserId),
									_bstr_t(pszPassword), adOpenUnspecified);

		// Write one row per line item
		
		for (int ix = 0; ix < m_veclItemId.size() && SUCCEEDED(hr); ix++)
		{
			TCHAR szSQLStmt[1024];	// SQL statement buffer

			LPCTSTR pszPrototypeInsertStmt =
				_T("insert into QCSampleShip ")
				_T(" (order_id, cust_id, line_no, ")
				_T("  item_id, quantity, ship_status_enum) ")
				_T("values(%ld, %ld, %ld, %ld, %ld, %ld)");

			wsprintf(	szSQLStmt,
						pszPrototypeInsertStmt,
						m_lOrderId,
						m_lCustomerId,
						ix,
						m_veclItemId[ix],
						m_veclQuantity[ix],
						m_vecShipStatus[ix]);
		
			hr = pADOConnection->Execute(_bstr_t(szSQLStmt), NULL, adCmdText, NULL);
		}
	}

	return hr;
}

/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  THIS IS A PRIVATE MEMBER FUNCTION

  Method:   COShip2::NotifyRequestor
  Summary:  Creates Notify object to return shipping status to requestor.
  Args:     long	lFlags - processing option flags
  Modifies: None
  Returns:  HRESULT	- returns failure from embedded function requests or S_OK.
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/ 

HRESULT COShip2::NotifyRequestor(long lFlags, IUnknown *punkNotify)
{
	HRESULT hr = S_OK;

	if (lFlags & processFlagLateBound)
		hr = InvokeNotifyIDispatch(punkNotify, lFlags);
	else
		hr = InvokeNotifyVtable(punkNotify, lFlags);
	return hr;
}

/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  THIS IS A PRIVATE MEMBER FUNCTION

  Method:   COShip2::InvokeNotifyIDispatch
  Summary:  Invoke Notify object methods using IDispatch
  Args:     IUnknown *	punkShip - IUnknown * to Notify object
			long		lFlags	- flag longword with option bits   
  Modifies: None
  Returns:  HRESULT from the underlying requests
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/ 

HRESULT COShip2::InvokeNotifyIDispatch(IUnknown * punkNotify, long lFlags)
{
	HRESULT hr = S_OK;

	MessageBox(NULL, "Inside InvokeNotifyIDispatch!", "Arghh!", MB_OK);
	CComQIPtr<IDispatch, &IID_IDispatch> pIDispatch(punkNotify);
	
	if (!pIDispatch) hr = E_NOINTERFACE;

	// Set CustomerId property

	if (SUCCEEDED(hr))
	{
		const int nNames = 1;

		OLECHAR *	rgszNames[nNames] = { OLESTR("CustomerId") };
		DISPID		dispId[nNames];

		hr = pIDispatch->GetIDsOfNames( IID_NULL, rgszNames, nNames, 
										LOCALE_SYSTEM_DEFAULT, dispId);
		if (SUCCEEDED(hr))
		{
			CComVariant	varData(m_lCustomerId);
			DISPID		dispidPut = DISPID_PROPERTYPUT;
			DISPPARAMS	dispparams = {&varData, &dispidPut, 1, 1};
	
			hr = pIDispatch->Invoke(dispId[0], IID_NULL, LOCALE_USER_DEFAULT, 
									DISPATCH_PROPERTYPUT, &dispparams, NULL, NULL, NULL);
		}
	}

	// Set OrderId property

	if (SUCCEEDED(hr))
	{
		const int nNames = 1;
	
		OLECHAR *	rgszNames[nNames] = { OLESTR("OrderId") };
		DISPID		dispId[nNames];

		hr = pIDispatch->GetIDsOfNames(	IID_NULL, rgszNames, nNames, 
										LOCALE_SYSTEM_DEFAULT, dispId);
		if (SUCCEEDED(hr))
		{
			CComVariant	varData(m_lOrderId);
			DISPID		dispidPut = DISPID_PROPERTYPUT;
			DISPPARAMS	dispparams = {&varData, &dispidPut, 1, 1};
	
			hr = pIDispatch->Invoke(dispId[0], IID_NULL, LOCALE_USER_DEFAULT, 
									DISPATCH_PROPERTYPUT, &dispparams, NULL, NULL, NULL);
		}
	}

	// Call LineItem method once for each line item

	if (SUCCEEDED(hr))
	{
		const int nNames = 4;

		OLECHAR *	rgszNames[nNames] = {	OLESTR("LineItem"),		// method name
											OLESTR("lItemId"),		// parm name
											OLESTR("lQuantity"),
											OLESTR("shipStatus") };	// parm name
		DISPID		dispId[nNames];

		hr = pIDispatch->GetIDsOfNames(	IID_NULL, rgszNames, nNames, 
										LOCALE_SYSTEM_DEFAULT, dispId);

		for (int ix = 0; ix < m_veclItemId.size() && SUCCEEDED(hr); ix++)
		{
			const int nArgs = nNames - 1;

			CComVariant varData[nArgs];		// 2 Arguments
			varData[0] = m_veclItemId[ix];
			varData[1] = m_veclQuantity[ix];
			varData[2] = m_vecShipStatus[ix];

			DISPPARAMS dispparams = {varData, &dispId[1], nArgs, nArgs};
	
			hr = pIDispatch->Invoke(dispId[0], IID_NULL, LOCALE_USER_DEFAULT, 
									DISPATCH_METHOD, &dispparams, NULL, NULL, NULL);
		}
	}

	// Call Process method

	if (SUCCEEDED(hr))
	{	
		const int nNames = 2;

		OLECHAR *	rgszNames[nNames] = {	OLESTR("Process"),		// method name
											OLESTR("lFlags") };		// parm name
		DISPID		dispId[nNames];

		hr = pIDispatch->GetIDsOfNames(	IID_NULL, rgszNames, nNames, 
										LOCALE_SYSTEM_DEFAULT, dispId);
		if (SUCCEEDED(hr))
		{
			const int nArgs = nNames - 1;

			CComVariant varData[nArgs];	// just the parameters 
			varData[0] = lFlags;

			DISPPARAMS	dispparams = {varData, &dispId[1], nArgs, 0};

			hr = pIDispatch->Invoke(dispId[0], IID_NULL, LOCALE_USER_DEFAULT, 
									DISPATCH_METHOD, &dispparams, NULL, NULL, NULL);
		}
	}
	return hr;
}

/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  THIS IS A PRIVATE MEMBER FUNCTION

  Method:   COShip2::InvokeNotifyVtable
  Summary:  Calls Notify object methods using vtable
  Args:     long	lFlags - processing option flags
  Modifies: None
  Returns:  HRESULT	- returns failure from embedded function requests or S_OK.
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/ 

HRESULT COShip2::InvokeNotifyVtable(IUnknown * punkNotify, long lFlags)
{
	HRESULT hr = S_OK;

	CComQIPtr<INotify, &IID_INotify> pNotify(punkNotify);

	if (!pNotify) hr = E_NOINTERFACE;

	if (SUCCEEDED(hr)) hr = pNotify->put_CustomerId(m_lCustomerId);

	if (SUCCEEDED(hr)) hr = pNotify->put_OrderId(m_lOrderId);

	for (int ix = 0; ix < m_veclItemId.size() && SUCCEEDED(hr); ix++)
	{
		hr = pNotify->LineItem(m_veclItemId[ix], m_veclQuantity[ix], m_vecShipStatus[ix]);
	}

	if (SUCCEEDED(hr)) hr = pNotify->Process(lFlags); 

	return hr;
}

/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  THIS IS A PRIVATE MEMBER FUNCTION

  Method:   COShip2::RandomShipStatus
  Summary:  Determines shipping status for a particular line item.
			The status is derived from a random number, but is skewed
			so that most shipments are successful.
  Args:     None
  Modifies: None
  Returns:  ShipStatus - an enumeration declared in QCSamp2.idl
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/ 

ShipStatus COShip2::RandomShipStatus()
{
	const int iRandom = rand() % 100;

	if (iRandom < 80)	return ssShipped;		// 80% are shipped
	if (iRandom < 93)	return ssBackOrdered;	// 13% are back ordered
	if (iRandom < 97)	return ssNotStocked;	//  4% are not stocked
						return ssUnrecognizedItem;	//  3% have an invalid item number
}
